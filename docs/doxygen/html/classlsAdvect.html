<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ViennaLS: lsAdvect&lt; T, D &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ViennaLS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classlsAdvect.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classlsAdvect-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">lsAdvect&lt; T, D &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class is used to advance level sets over time. Level sets are passed to the constructor in an std::vector, with the last element being the level set to advect, or "top level set", while the others are then adjusted afterwards. In order to ensure that advection works correctly, the "top level set" has to include all lower level sets: LS_top = LS_top U LS_i for i = {0 ... n}, where n is the number of level sets. The velocities used to advect the level set are given in a concrete implementation of the <a class="el" href="classlsVelocityField.html" title="Abstract class defining the interface for the velocity field used during advection using lsAdvect.">lsVelocityField</a> (check Advection examples for guidance)  
 <a href="classlsAdvect.html#details">More...</a></p>

<p><code>#include &lt;lsAdvect.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a04133cfc8f477fa8357e8ebda371dc1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a04133cfc8f477fa8357e8ebda371dc1d">lsAdvect</a> ()</td></tr>
<tr class="separator:a04133cfc8f477fa8357e8ebda371dc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a519664b3d7b333fd4800692b0e13ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a2a519664b3d7b333fd4800692b0e13ad">lsAdvect</a> (<a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt; passedlsDomain)</td></tr>
<tr class="separator:a2a519664b3d7b333fd4800692b0e13ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d918cef7cb999db48fa93a96828f0d"><td class="memTemplParams" colspan="2">template&lt;class VelocityField &gt; </td></tr>
<tr class="memitem:a01d918cef7cb999db48fa93a96828f0d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a01d918cef7cb999db48fa93a96828f0d">lsAdvect</a> (<a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt; passedlsDomain, <a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt; passedVelocities)</td></tr>
<tr class="separator:a01d918cef7cb999db48fa93a96828f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2368631b9ced18dd258ad92611058d6c"><td class="memTemplParams" colspan="2">template&lt;class VelocityField , <a class="el" href="namespacelsConcepts.html#a90d0ed377343607596475f042f71ae47">lsConcepts::IsBaseOf</a>&lt; <a class="el" href="classlsVelocityField.html">lsVelocityField</a>&lt; T &gt;, VelocityField &gt;  = lsConcepts::assignable&gt; </td></tr>
<tr class="memitem:a2368631b9ced18dd258ad92611058d6c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a2368631b9ced18dd258ad92611058d6c">lsAdvect</a> (<a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt; passedVelocities)</td></tr>
<tr class="separator:a2368631b9ced18dd258ad92611058d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0237e760f65750ed22baf06a07b3e7ad"><td class="memTemplParams" colspan="2">template&lt;class VelocityField , <a class="el" href="namespacelsConcepts.html#a90d0ed377343607596475f042f71ae47">lsConcepts::IsBaseOf</a>&lt; <a class="el" href="classlsVelocityField.html">lsVelocityField</a>&lt; T &gt;, VelocityField &gt;  = lsConcepts::assignable&gt; </td></tr>
<tr class="memitem:a0237e760f65750ed22baf06a07b3e7ad"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a0237e760f65750ed22baf06a07b3e7ad">lsAdvect</a> (std::vector&lt; <a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt; &gt; passedlsDomains, <a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt; passedVelocities)</td></tr>
<tr class="separator:a0237e760f65750ed22baf06a07b3e7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d63f7b5dc62228e734223f5855a9c8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a7d63f7b5dc62228e734223f5855a9c8f">insertNextLevelSet</a> (<a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt; passedlsDomain)</td></tr>
<tr class="memdesc:a7d63f7b5dc62228e734223f5855a9c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the passed level set to the back of the list of level sets used for advection.  <a href="classlsAdvect.html#a7d63f7b5dc62228e734223f5855a9c8f">More...</a><br /></td></tr>
<tr class="separator:a7d63f7b5dc62228e734223f5855a9c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f8966aac303d434345cca2b6139815"><td class="memTemplParams" colspan="2">template&lt;class VelocityField , <a class="el" href="namespacelsConcepts.html#a90d0ed377343607596475f042f71ae47">lsConcepts::IsBaseOf</a>&lt; <a class="el" href="classlsVelocityField.html">lsVelocityField</a>&lt; T &gt;, VelocityField &gt;  = lsConcepts::assignable&gt; </td></tr>
<tr class="memitem:a33f8966aac303d434345cca2b6139815"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a33f8966aac303d434345cca2b6139815">setVelocityField</a> (<a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt; passedVelocities)</td></tr>
<tr class="memdesc:a33f8966aac303d434345cca2b6139815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the velocity field used for advection. This should be a concrete implementation of <a class="el" href="classlsVelocityField.html" title="Abstract class defining the interface for the velocity field used during advection using lsAdvect.">lsVelocityField</a>.  <a href="classlsAdvect.html#a33f8966aac303d434345cca2b6139815">More...</a><br /></td></tr>
<tr class="separator:a33f8966aac303d434345cca2b6139815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0504339e8d545dfec417acd5c6b0eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#ad0504339e8d545dfec417acd5c6b0eb7">setAdvectionTime</a> (double time)</td></tr>
<tr class="memdesc:ad0504339e8d545dfec417acd5c6b0eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time until when the level set should be advected. If this takes more than one advection step, multiple will be performed. Defaults to 0, which means one advection step with the maximum time step possible according to the CFL condition(see setTimeStepRatio) will be performed.  <a href="classlsAdvect.html#ad0504339e8d545dfec417acd5c6b0eb7">More...</a><br /></td></tr>
<tr class="separator:ad0504339e8d545dfec417acd5c6b0eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf51dda5ac4830d9b54f1d4ef15ba57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#accf51dda5ac4830d9b54f1d4ef15ba57">setSingleStep</a> (bool singleStep)</td></tr>
<tr class="memdesc:accf51dda5ac4830d9b54f1d4ef15ba57"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to true, only a single advection step will be performed, even if the advection time set with <a class="el" href="classlsAdvect.html#ad0504339e8d545dfec417acd5c6b0eb7" title="Set the time until when the level set should be advected. If this takes more than one advection step,...">setAdvectionTime(double)</a> would require several steps to pass. Defaults to false.  <a href="classlsAdvect.html#accf51dda5ac4830d9b54f1d4ef15ba57">More...</a><br /></td></tr>
<tr class="separator:accf51dda5ac4830d9b54f1d4ef15ba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ec99a52859c693e3c8741f50329a7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#ac1ec99a52859c693e3c8741f50329a7e">setTimeStepRatio</a> (const double &amp;cfl)</td></tr>
<tr class="memdesc:ac1ec99a52859c693e3c8741f50329a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CFL condition to use during advection. The CFL condition sets the maximum distance a surface can be moved during one advection step. It MUST be below 0.5 to guarantee numerical stability. Defaults to 0.4999.  <a href="classlsAdvect.html#ac1ec99a52859c693e3c8741f50329a7e">More...</a><br /></td></tr>
<tr class="separator:ac1ec99a52859c693e3c8741f50329a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aba91f9cccd19247a5017d9b1b4142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#aa2aba91f9cccd19247a5017d9b1b4142">setCalculateNormalVectors</a> (bool cnv)</td></tr>
<tr class="memdesc:aa2aba91f9cccd19247a5017d9b1b4142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether normal vectors should be calculated at each level set point. Defaults to true. If normal vectors are not required for velocity calculation, this can be set to false, in order to increase computational efficiency.  <a href="classlsAdvect.html#aa2aba91f9cccd19247a5017d9b1b4142">More...</a><br /></td></tr>
<tr class="separator:aa2aba91f9cccd19247a5017d9b1b4142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520e28feacd2655a4eff2a33e1d7f92d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a520e28feacd2655a4eff2a33e1d7f92d">setIgnoreVoids</a> (bool iV)</td></tr>
<tr class="memdesc:a520e28feacd2655a4eff2a33e1d7f92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether level set values, which are not part of the "top" geometrically connected part of values, should be advected. The "top" part is identified by the most positive part in the lowest dimension with INFINITE boundary conditions. Defaults to false. If set to true, only the "top" values will be advected. All others values are not changed.  <a href="classlsAdvect.html#a520e28feacd2655a4eff2a33e1d7f92d">More...</a><br /></td></tr>
<tr class="separator:a520e28feacd2655a4eff2a33e1d7f92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f78eb026aa00ec77cf420fe3674dd03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a1f78eb026aa00ec77cf420fe3674dd03">setSaveAdvectionVelocities</a> (bool sAV)</td></tr>
<tr class="memdesc:a1f78eb026aa00ec77cf420fe3674dd03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the velocities applied to each point should be saved in the level set for debug purposes.  <a href="classlsAdvect.html#a1f78eb026aa00ec77cf420fe3674dd03">More...</a><br /></td></tr>
<tr class="separator:a1f78eb026aa00ec77cf420fe3674dd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3aa1882d86169065989b55c839f061a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#ab3aa1882d86169065989b55c839f061a">getAdvectedTime</a> ()</td></tr>
<tr class="memdesc:ab3aa1882d86169065989b55c839f061a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get by how much the physical time was advanced during the last <a class="el" href="classlsAdvect.html#a7b6f35f0b35133d40ceeb866b5c733f3" title="Perform the advection.">apply()</a> call.  <a href="classlsAdvect.html#ab3aa1882d86169065989b55c839f061a">More...</a><br /></td></tr>
<tr class="separator:ab3aa1882d86169065989b55c839f061a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a15f986e3037afa870d4a5aab5162b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a77a15f986e3037afa870d4a5aab5162b">getNumberOfTimeSteps</a> ()</td></tr>
<tr class="memdesc:a77a15f986e3037afa870d4a5aab5162b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get how many advection steps were performed during the last <a class="el" href="classlsAdvect.html#a7b6f35f0b35133d40ceeb866b5c733f3" title="Perform the advection.">apply()</a> call.  <a href="classlsAdvect.html#a77a15f986e3037afa870d4a5aab5162b">More...</a><br /></td></tr>
<tr class="separator:a77a15f986e3037afa870d4a5aab5162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65951348ca5870a5b0caa8196358bdc2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a65951348ca5870a5b0caa8196358bdc2">getTimeStepRatio</a> ()</td></tr>
<tr class="memdesc:a65951348ca5870a5b0caa8196358bdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the CFL number.  <a href="classlsAdvect.html#a65951348ca5870a5b0caa8196358bdc2">More...</a><br /></td></tr>
<tr class="separator:a65951348ca5870a5b0caa8196358bdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9e64c2f053d28d459d5742f18f424b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a8a9e64c2f053d28d459d5742f18f424b">getCalculateNormalVectors</a> ()</td></tr>
<tr class="memdesc:a8a9e64c2f053d28d459d5742f18f424b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether normal vectors were caluclated.  <a href="classlsAdvect.html#a8a9e64c2f053d28d459d5742f18f424b">More...</a><br /></td></tr>
<tr class="separator:a8a9e64c2f053d28d459d5742f18f424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f46e20b204edca8a987514909e34907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a5f46e20b204edca8a987514909e34907">setIntegrationScheme</a> (<a class="el" href="include_2lsAdvect_8hpp.html#afe9778bbf7b5f9aeb52d14c4f133cc9b">lsIntegrationSchemeEnum</a> scheme)</td></tr>
<tr class="memdesc:a5f46e20b204edca8a987514909e34907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set which integration scheme should be used out of the ones specified in lsIntegrationSchemeEnum.  <a href="classlsAdvect.html#a5f46e20b204edca8a987514909e34907">More...</a><br /></td></tr>
<tr class="separator:a5f46e20b204edca8a987514909e34907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af644ebf0efd6dbef33865a9c5c61988c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#af644ebf0efd6dbef33865a9c5c61988c">setDissipationAlpha</a> (const double &amp;a)</td></tr>
<tr class="memdesc:af644ebf0efd6dbef33865a9c5c61988c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the alpha dissipation coefficient. For lsLaxFriedrichs, this is used as the alpha value. For all other LaxFriedrichs schemes it is used as a scaling factor for the calculated alpha values.  <a href="classlsAdvect.html#af644ebf0efd6dbef33865a9c5c61988c">More...</a><br /></td></tr>
<tr class="separator:af644ebf0efd6dbef33865a9c5c61988c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b680304b836eaf906539a86633b1ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a58b680304b836eaf906539a86633b1ab">setUpdatePointData</a> (bool update)</td></tr>
<tr class="memdesc:a58b680304b836eaf906539a86633b1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the point data in the old LS should be translated to the advected LS. Defaults to true.  <a href="classlsAdvect.html#a58b680304b836eaf906539a86633b1ab">More...</a><br /></td></tr>
<tr class="separator:a58b680304b836eaf906539a86633b1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6f35f0b35133d40ceeb866b5c733f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a7b6f35f0b35133d40ceeb866b5c733f3">apply</a> ()</td></tr>
<tr class="memdesc:a7b6f35f0b35133d40ceeb866b5c733f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the advection.  <a href="classlsAdvect.html#a7b6f35f0b35133d40ceeb866b5c733f3">More...</a><br /></td></tr>
<tr class="separator:a7b6f35f0b35133d40ceeb866b5c733f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04133cfc8f477fa8357e8ebda371dc1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a04133cfc8f477fa8357e8ebda371dc1d">lsAdvect</a> ()</td></tr>
<tr class="separator:a04133cfc8f477fa8357e8ebda371dc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a519664b3d7b333fd4800692b0e13ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a2a519664b3d7b333fd4800692b0e13ad">lsAdvect</a> (<a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt; passedlsDomain)</td></tr>
<tr class="separator:a2a519664b3d7b333fd4800692b0e13ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d918cef7cb999db48fa93a96828f0d"><td class="memTemplParams" colspan="2">template&lt;class VelocityField &gt; </td></tr>
<tr class="memitem:a01d918cef7cb999db48fa93a96828f0d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a01d918cef7cb999db48fa93a96828f0d">lsAdvect</a> (<a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt; passedlsDomain, <a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt; passedVelocities)</td></tr>
<tr class="separator:a01d918cef7cb999db48fa93a96828f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2368631b9ced18dd258ad92611058d6c"><td class="memTemplParams" colspan="2">template&lt;class VelocityField , <a class="el" href="namespacelsConcepts.html#a90d0ed377343607596475f042f71ae47">lsConcepts::IsBaseOf</a>&lt; <a class="el" href="classlsVelocityField.html">lsVelocityField</a>&lt; T &gt;, VelocityField &gt;  = lsConcepts::assignable&gt; </td></tr>
<tr class="memitem:a2368631b9ced18dd258ad92611058d6c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a2368631b9ced18dd258ad92611058d6c">lsAdvect</a> (<a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt; passedVelocities)</td></tr>
<tr class="separator:a2368631b9ced18dd258ad92611058d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0237e760f65750ed22baf06a07b3e7ad"><td class="memTemplParams" colspan="2">template&lt;class VelocityField , <a class="el" href="namespacelsConcepts.html#a90d0ed377343607596475f042f71ae47">lsConcepts::IsBaseOf</a>&lt; <a class="el" href="classlsVelocityField.html">lsVelocityField</a>&lt; T &gt;, VelocityField &gt;  = lsConcepts::assignable&gt; </td></tr>
<tr class="memitem:a0237e760f65750ed22baf06a07b3e7ad"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a0237e760f65750ed22baf06a07b3e7ad">lsAdvect</a> (std::vector&lt; <a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt; &gt; passedlsDomains, <a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt; passedVelocities)</td></tr>
<tr class="separator:a0237e760f65750ed22baf06a07b3e7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d63f7b5dc62228e734223f5855a9c8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a7d63f7b5dc62228e734223f5855a9c8f">insertNextLevelSet</a> (<a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt; passedlsDomain)</td></tr>
<tr class="memdesc:a7d63f7b5dc62228e734223f5855a9c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the passed level set to the back of the list of level sets used for advection.  <a href="classlsAdvect.html#a7d63f7b5dc62228e734223f5855a9c8f">More...</a><br /></td></tr>
<tr class="separator:a7d63f7b5dc62228e734223f5855a9c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f8966aac303d434345cca2b6139815"><td class="memTemplParams" colspan="2">template&lt;class VelocityField , <a class="el" href="namespacelsConcepts.html#a90d0ed377343607596475f042f71ae47">lsConcepts::IsBaseOf</a>&lt; <a class="el" href="classlsVelocityField.html">lsVelocityField</a>&lt; T &gt;, VelocityField &gt;  = lsConcepts::assignable&gt; </td></tr>
<tr class="memitem:a33f8966aac303d434345cca2b6139815"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a33f8966aac303d434345cca2b6139815">setVelocityField</a> (<a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt; passedVelocities)</td></tr>
<tr class="memdesc:a33f8966aac303d434345cca2b6139815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the velocity field used for advection. This should be a concrete implementation of <a class="el" href="classlsVelocityField.html" title="Abstract class defining the interface for the velocity field used during advection using lsAdvect.">lsVelocityField</a>.  <a href="classlsAdvect.html#a33f8966aac303d434345cca2b6139815">More...</a><br /></td></tr>
<tr class="separator:a33f8966aac303d434345cca2b6139815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0504339e8d545dfec417acd5c6b0eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#ad0504339e8d545dfec417acd5c6b0eb7">setAdvectionTime</a> (double time)</td></tr>
<tr class="memdesc:ad0504339e8d545dfec417acd5c6b0eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time until when the level set should be advected. If this takes more than one advection step, multiple will be performed. Defaults to 0, which means one advection step with the maximum time step possible according to the CFL condition(see setTimeStepRatio) will be performed.  <a href="classlsAdvect.html#ad0504339e8d545dfec417acd5c6b0eb7">More...</a><br /></td></tr>
<tr class="separator:ad0504339e8d545dfec417acd5c6b0eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf51dda5ac4830d9b54f1d4ef15ba57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#accf51dda5ac4830d9b54f1d4ef15ba57">setSingleStep</a> (bool singleStep)</td></tr>
<tr class="memdesc:accf51dda5ac4830d9b54f1d4ef15ba57"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to true, only a single advection step will be performed, even if the advection time set with <a class="el" href="classlsAdvect.html#ad0504339e8d545dfec417acd5c6b0eb7" title="Set the time until when the level set should be advected. If this takes more than one advection step,...">setAdvectionTime(double)</a> would require several steps to pass. Defaults to false.  <a href="classlsAdvect.html#accf51dda5ac4830d9b54f1d4ef15ba57">More...</a><br /></td></tr>
<tr class="separator:accf51dda5ac4830d9b54f1d4ef15ba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ec99a52859c693e3c8741f50329a7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#ac1ec99a52859c693e3c8741f50329a7e">setTimeStepRatio</a> (const double &amp;cfl)</td></tr>
<tr class="memdesc:ac1ec99a52859c693e3c8741f50329a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CFL condition to use during advection. The CFL condition sets the maximum distance a surface can be moved during one advection step. It MUST be below 0.5 to guarantee numerical stability. Defaults to 0.4999.  <a href="classlsAdvect.html#ac1ec99a52859c693e3c8741f50329a7e">More...</a><br /></td></tr>
<tr class="separator:ac1ec99a52859c693e3c8741f50329a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aba91f9cccd19247a5017d9b1b4142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#aa2aba91f9cccd19247a5017d9b1b4142">setCalculateNormalVectors</a> (bool cnv)</td></tr>
<tr class="memdesc:aa2aba91f9cccd19247a5017d9b1b4142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether normal vectors should be calculated at each level set point. Defaults to true. If normal vectors are not required for velocity calculation, this can be set to false, in order to increase computational efficiency.  <a href="classlsAdvect.html#aa2aba91f9cccd19247a5017d9b1b4142">More...</a><br /></td></tr>
<tr class="separator:aa2aba91f9cccd19247a5017d9b1b4142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520e28feacd2655a4eff2a33e1d7f92d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a520e28feacd2655a4eff2a33e1d7f92d">setIgnoreVoids</a> (bool iV)</td></tr>
<tr class="memdesc:a520e28feacd2655a4eff2a33e1d7f92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether level set values, which are not part of the "top" geometrically connected part of values, should be advected. The "top" part is identified by the most positive part in the lowest dimension with INFINITE boundary conditions. Defaults to false. If set to true, only the "top" values will be advected. All others values are not changed.  <a href="classlsAdvect.html#a520e28feacd2655a4eff2a33e1d7f92d">More...</a><br /></td></tr>
<tr class="separator:a520e28feacd2655a4eff2a33e1d7f92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f78eb026aa00ec77cf420fe3674dd03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a1f78eb026aa00ec77cf420fe3674dd03">setSaveAdvectionVelocities</a> (bool sAV)</td></tr>
<tr class="memdesc:a1f78eb026aa00ec77cf420fe3674dd03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the velocities applied to each point should be saved in the level set for debug purposes.  <a href="classlsAdvect.html#a1f78eb026aa00ec77cf420fe3674dd03">More...</a><br /></td></tr>
<tr class="separator:a1f78eb026aa00ec77cf420fe3674dd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3aa1882d86169065989b55c839f061a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#ab3aa1882d86169065989b55c839f061a">getAdvectedTime</a> ()</td></tr>
<tr class="memdesc:ab3aa1882d86169065989b55c839f061a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get by how much the physical time was advanced during the last <a class="el" href="classlsAdvect.html#a7b6f35f0b35133d40ceeb866b5c733f3" title="Perform the advection.">apply()</a> call.  <a href="classlsAdvect.html#ab3aa1882d86169065989b55c839f061a">More...</a><br /></td></tr>
<tr class="separator:ab3aa1882d86169065989b55c839f061a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a15f986e3037afa870d4a5aab5162b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a77a15f986e3037afa870d4a5aab5162b">getNumberOfTimeSteps</a> ()</td></tr>
<tr class="memdesc:a77a15f986e3037afa870d4a5aab5162b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get how many advection steps were performed during the last <a class="el" href="classlsAdvect.html#a7b6f35f0b35133d40ceeb866b5c733f3" title="Perform the advection.">apply()</a> call.  <a href="classlsAdvect.html#a77a15f986e3037afa870d4a5aab5162b">More...</a><br /></td></tr>
<tr class="separator:a77a15f986e3037afa870d4a5aab5162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65951348ca5870a5b0caa8196358bdc2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a65951348ca5870a5b0caa8196358bdc2">getTimeStepRatio</a> ()</td></tr>
<tr class="memdesc:a65951348ca5870a5b0caa8196358bdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the CFL number.  <a href="classlsAdvect.html#a65951348ca5870a5b0caa8196358bdc2">More...</a><br /></td></tr>
<tr class="separator:a65951348ca5870a5b0caa8196358bdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9e64c2f053d28d459d5742f18f424b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a8a9e64c2f053d28d459d5742f18f424b">getCalculateNormalVectors</a> ()</td></tr>
<tr class="memdesc:a8a9e64c2f053d28d459d5742f18f424b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether normal vectors were caluclated.  <a href="classlsAdvect.html#a8a9e64c2f053d28d459d5742f18f424b">More...</a><br /></td></tr>
<tr class="separator:a8a9e64c2f053d28d459d5742f18f424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f46e20b204edca8a987514909e34907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a5f46e20b204edca8a987514909e34907">setIntegrationScheme</a> (<a class="el" href="include_2lsAdvect_8hpp.html#afe9778bbf7b5f9aeb52d14c4f133cc9b">lsIntegrationSchemeEnum</a> scheme)</td></tr>
<tr class="memdesc:a5f46e20b204edca8a987514909e34907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set which integration scheme should be used out of the ones specified in lsIntegrationSchemeEnum.  <a href="classlsAdvect.html#a5f46e20b204edca8a987514909e34907">More...</a><br /></td></tr>
<tr class="separator:a5f46e20b204edca8a987514909e34907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af644ebf0efd6dbef33865a9c5c61988c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#af644ebf0efd6dbef33865a9c5c61988c">setDissipationAlpha</a> (const double &amp;a)</td></tr>
<tr class="memdesc:af644ebf0efd6dbef33865a9c5c61988c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the alpha dissipation coefficient. For lsLaxFriedrichs, this is used as the alpha value. For all other LaxFriedrichs schemes it is used as a scaling factor for the calculated alpha values.  <a href="classlsAdvect.html#af644ebf0efd6dbef33865a9c5c61988c">More...</a><br /></td></tr>
<tr class="separator:af644ebf0efd6dbef33865a9c5c61988c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b680304b836eaf906539a86633b1ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a58b680304b836eaf906539a86633b1ab">setUpdatePointData</a> (bool update)</td></tr>
<tr class="memdesc:a58b680304b836eaf906539a86633b1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the point data in the old LS should be translated to the advected LS. Defaults to true.  <a href="classlsAdvect.html#a58b680304b836eaf906539a86633b1ab">More...</a><br /></td></tr>
<tr class="separator:a58b680304b836eaf906539a86633b1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6f35f0b35133d40ceeb866b5c733f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#a7b6f35f0b35133d40ceeb866b5c733f3">apply</a> ()</td></tr>
<tr class="memdesc:a7b6f35f0b35133d40ceeb866b5c733f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the advection.  <a href="classlsAdvect.html#a7b6f35f0b35133d40ceeb866b5c733f3">More...</a><br /></td></tr>
<tr class="separator:a7b6f35f0b35133d40ceeb866b5c733f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:afae1b077486e6aa98c423cbe0b84c2e0"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlsAdvect.html#afae1b077486e6aa98c423cbe0b84c2e0">velocityLabel</a> []</td></tr>
<tr class="separator:afae1b077486e6aa98c423cbe0b84c2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, int D&gt;<br />
class lsAdvect&lt; T, D &gt;</div><p >This class is used to advance level sets over time. Level sets are passed to the constructor in an std::vector, with the last element being the level set to advect, or "top level set", while the others are then adjusted afterwards. In order to ensure that advection works correctly, the "top level set" has to include all lower level sets: LS_top = LS_top U LS_i for i = {0 ... n}, where n is the number of level sets. The velocities used to advect the level set are given in a concrete implementation of the <a class="el" href="classlsVelocityField.html" title="Abstract class defining the interface for the velocity field used during advection using lsAdvect.">lsVelocityField</a> (check Advection examples for guidance) </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AirGapDeposition_8cpp-example.html#_a31">AirGapDeposition.cpp</a>, <a class="el" href="Deposition_8cpp-example.html#_a29">Deposition.cpp</a>, <a class="el" href="PatternedSubstrate_8cpp-example.html#_a24">PatternedSubstrate.cpp</a>, <a class="el" href="PeriodicBoundary_8cpp-example.html#_a24">PeriodicBoundary.cpp</a>, <a class="el" href="SquareEtch_8cpp-example.html#_a30">SquareEtch.cpp</a>, and <a class="el" href="VoidEtching_8cpp-example.html#_a20">VoidEtching.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a04133cfc8f477fa8357e8ebda371dc1d" name="a04133cfc8f477fa8357e8ebda371dc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04133cfc8f477fa8357e8ebda371dc1d">&#9670;&nbsp;</a></span>lsAdvect() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;<a class="el" href="classlsAdvect.html">::lsAdvect</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a519664b3d7b333fd4800692b0e13ad" name="a2a519664b3d7b333fd4800692b0e13ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a519664b3d7b333fd4800692b0e13ad">&#9670;&nbsp;</a></span>lsAdvect() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;<a class="el" href="classlsAdvect.html">::lsAdvect</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt;&#160;</td>
          <td class="paramname"><em>passedlsDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01d918cef7cb999db48fa93a96828f0d" name="a01d918cef7cb999db48fa93a96828f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d918cef7cb999db48fa93a96828f0d">&#9670;&nbsp;</a></span>lsAdvect() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<div class="memtemplate">
template&lt;class VelocityField &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;<a class="el" href="classlsAdvect.html">::lsAdvect</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt;&#160;</td>
          <td class="paramname"><em>passedlsDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt;&#160;</td>
          <td class="paramname"><em>passedVelocities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2368631b9ced18dd258ad92611058d6c" name="a2368631b9ced18dd258ad92611058d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2368631b9ced18dd258ad92611058d6c">&#9670;&nbsp;</a></span>lsAdvect() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<div class="memtemplate">
template&lt;class VelocityField , <a class="el" href="namespacelsConcepts.html#a90d0ed377343607596475f042f71ae47">lsConcepts::IsBaseOf</a>&lt; <a class="el" href="classlsVelocityField.html">lsVelocityField</a>&lt; T &gt;, VelocityField &gt;  = lsConcepts::assignable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;<a class="el" href="classlsAdvect.html">::lsAdvect</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt;&#160;</td>
          <td class="paramname"><em>passedVelocities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0237e760f65750ed22baf06a07b3e7ad" name="a0237e760f65750ed22baf06a07b3e7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0237e760f65750ed22baf06a07b3e7ad">&#9670;&nbsp;</a></span>lsAdvect() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<div class="memtemplate">
template&lt;class VelocityField , <a class="el" href="namespacelsConcepts.html#a90d0ed377343607596475f042f71ae47">lsConcepts::IsBaseOf</a>&lt; <a class="el" href="classlsVelocityField.html">lsVelocityField</a>&lt; T &gt;, VelocityField &gt;  = lsConcepts::assignable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;<a class="el" href="classlsAdvect.html">::lsAdvect</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>passedlsDomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt;&#160;</td>
          <td class="paramname"><em>passedVelocities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04133cfc8f477fa8357e8ebda371dc1d" name="a04133cfc8f477fa8357e8ebda371dc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04133cfc8f477fa8357e8ebda371dc1d">&#9670;&nbsp;</a></span>lsAdvect() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;<a class="el" href="classlsAdvect.html">::lsAdvect</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a519664b3d7b333fd4800692b0e13ad" name="a2a519664b3d7b333fd4800692b0e13ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a519664b3d7b333fd4800692b0e13ad">&#9670;&nbsp;</a></span>lsAdvect() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;<a class="el" href="classlsAdvect.html">::lsAdvect</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt;&#160;</td>
          <td class="paramname"><em>passedlsDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01d918cef7cb999db48fa93a96828f0d" name="a01d918cef7cb999db48fa93a96828f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d918cef7cb999db48fa93a96828f0d">&#9670;&nbsp;</a></span>lsAdvect() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<div class="memtemplate">
template&lt;class VelocityField &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;<a class="el" href="classlsAdvect.html">::lsAdvect</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt;&#160;</td>
          <td class="paramname"><em>passedlsDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt;&#160;</td>
          <td class="paramname"><em>passedVelocities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2368631b9ced18dd258ad92611058d6c" name="a2368631b9ced18dd258ad92611058d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2368631b9ced18dd258ad92611058d6c">&#9670;&nbsp;</a></span>lsAdvect() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<div class="memtemplate">
template&lt;class VelocityField , <a class="el" href="namespacelsConcepts.html#a90d0ed377343607596475f042f71ae47">lsConcepts::IsBaseOf</a>&lt; <a class="el" href="classlsVelocityField.html">lsVelocityField</a>&lt; T &gt;, VelocityField &gt;  = lsConcepts::assignable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;<a class="el" href="classlsAdvect.html">::lsAdvect</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt;&#160;</td>
          <td class="paramname"><em>passedVelocities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0237e760f65750ed22baf06a07b3e7ad" name="a0237e760f65750ed22baf06a07b3e7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0237e760f65750ed22baf06a07b3e7ad">&#9670;&nbsp;</a></span>lsAdvect() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<div class="memtemplate">
template&lt;class VelocityField , <a class="el" href="namespacelsConcepts.html#a90d0ed377343607596475f042f71ae47">lsConcepts::IsBaseOf</a>&lt; <a class="el" href="classlsVelocityField.html">lsVelocityField</a>&lt; T &gt;, VelocityField &gt;  = lsConcepts::assignable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;<a class="el" href="classlsAdvect.html">::lsAdvect</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>passedlsDomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt;&#160;</td>
          <td class="paramname"><em>passedVelocities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7b6f35f0b35133d40ceeb866b5c733f3" name="a7b6f35f0b35133d40ceeb866b5c733f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6f35f0b35133d40ceeb866b5c733f3">&#9670;&nbsp;</a></span>apply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::apply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the advection. </p>

</div>
</div>
<a id="a7b6f35f0b35133d40ceeb866b5c733f3" name="a7b6f35f0b35133d40ceeb866b5c733f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6f35f0b35133d40ceeb866b5c733f3">&#9670;&nbsp;</a></span>apply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::apply </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the advection. </p>

</div>
</div>
<a id="ab3aa1882d86169065989b55c839f061a" name="ab3aa1882d86169065989b55c839f061a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3aa1882d86169065989b55c839f061a">&#9670;&nbsp;</a></span>getAdvectedTime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::getAdvectedTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get by how much the physical time was advanced during the last <a class="el" href="classlsAdvect.html#a7b6f35f0b35133d40ceeb866b5c733f3" title="Perform the advection.">apply()</a> call. </p>

</div>
</div>
<a id="ab3aa1882d86169065989b55c839f061a" name="ab3aa1882d86169065989b55c839f061a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3aa1882d86169065989b55c839f061a">&#9670;&nbsp;</a></span>getAdvectedTime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::getAdvectedTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get by how much the physical time was advanced during the last <a class="el" href="classlsAdvect.html#a7b6f35f0b35133d40ceeb866b5c733f3" title="Perform the advection.">apply()</a> call. </p>

</div>
</div>
<a id="a8a9e64c2f053d28d459d5742f18f424b" name="a8a9e64c2f053d28d459d5742f18f424b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9e64c2f053d28d459d5742f18f424b">&#9670;&nbsp;</a></span>getCalculateNormalVectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::getCalculateNormalVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether normal vectors were caluclated. </p>

</div>
</div>
<a id="a8a9e64c2f053d28d459d5742f18f424b" name="a8a9e64c2f053d28d459d5742f18f424b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9e64c2f053d28d459d5742f18f424b">&#9670;&nbsp;</a></span>getCalculateNormalVectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::getCalculateNormalVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether normal vectors were caluclated. </p>

</div>
</div>
<a id="a77a15f986e3037afa870d4a5aab5162b" name="a77a15f986e3037afa870d4a5aab5162b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a15f986e3037afa870d4a5aab5162b">&#9670;&nbsp;</a></span>getNumberOfTimeSteps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::getNumberOfTimeSteps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get how many advection steps were performed during the last <a class="el" href="classlsAdvect.html#a7b6f35f0b35133d40ceeb866b5c733f3" title="Perform the advection.">apply()</a> call. </p>

</div>
</div>
<a id="a77a15f986e3037afa870d4a5aab5162b" name="a77a15f986e3037afa870d4a5aab5162b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a15f986e3037afa870d4a5aab5162b">&#9670;&nbsp;</a></span>getNumberOfTimeSteps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::getNumberOfTimeSteps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get how many advection steps were performed during the last <a class="el" href="classlsAdvect.html#a7b6f35f0b35133d40ceeb866b5c733f3" title="Perform the advection.">apply()</a> call. </p>

</div>
</div>
<a id="a65951348ca5870a5b0caa8196358bdc2" name="a65951348ca5870a5b0caa8196358bdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65951348ca5870a5b0caa8196358bdc2">&#9670;&nbsp;</a></span>getTimeStepRatio() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::getTimeStepRatio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the CFL number. </p>

</div>
</div>
<a id="a65951348ca5870a5b0caa8196358bdc2" name="a65951348ca5870a5b0caa8196358bdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65951348ca5870a5b0caa8196358bdc2">&#9670;&nbsp;</a></span>getTimeStepRatio() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::getTimeStepRatio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the CFL number. </p>

</div>
</div>
<a id="a7d63f7b5dc62228e734223f5855a9c8f" name="a7d63f7b5dc62228e734223f5855a9c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d63f7b5dc62228e734223f5855a9c8f">&#9670;&nbsp;</a></span>insertNextLevelSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::insertNextLevelSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt;&#160;</td>
          <td class="paramname"><em>passedlsDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes the passed level set to the back of the list of level sets used for advection. </p>

</div>
</div>
<a id="a7d63f7b5dc62228e734223f5855a9c8f" name="a7d63f7b5dc62228e734223f5855a9c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d63f7b5dc62228e734223f5855a9c8f">&#9670;&nbsp;</a></span>insertNextLevelSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::insertNextLevelSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; <a class="el" href="classlsDomain.html">lsDomain</a>&lt; T, D &gt; &gt;&#160;</td>
          <td class="paramname"><em>passedlsDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes the passed level set to the back of the list of level sets used for advection. </p>

</div>
</div>
<a id="ad0504339e8d545dfec417acd5c6b0eb7" name="ad0504339e8d545dfec417acd5c6b0eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0504339e8d545dfec417acd5c6b0eb7">&#9670;&nbsp;</a></span>setAdvectionTime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setAdvectionTime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the time until when the level set should be advected. If this takes more than one advection step, multiple will be performed. Defaults to 0, which means one advection step with the maximum time step possible according to the CFL condition(see setTimeStepRatio) will be performed. </p>

</div>
</div>
<a id="ad0504339e8d545dfec417acd5c6b0eb7" name="ad0504339e8d545dfec417acd5c6b0eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0504339e8d545dfec417acd5c6b0eb7">&#9670;&nbsp;</a></span>setAdvectionTime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setAdvectionTime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the time until when the level set should be advected. If this takes more than one advection step, multiple will be performed. Defaults to 0, which means one advection step with the maximum time step possible according to the CFL condition(see setTimeStepRatio) will be performed. </p>

</div>
</div>
<a id="aa2aba91f9cccd19247a5017d9b1b4142" name="aa2aba91f9cccd19247a5017d9b1b4142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2aba91f9cccd19247a5017d9b1b4142">&#9670;&nbsp;</a></span>setCalculateNormalVectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setCalculateNormalVectors </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cnv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether normal vectors should be calculated at each level set point. Defaults to true. If normal vectors are not required for velocity calculation, this can be set to false, in order to increase computational efficiency. </p>

</div>
</div>
<a id="aa2aba91f9cccd19247a5017d9b1b4142" name="aa2aba91f9cccd19247a5017d9b1b4142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2aba91f9cccd19247a5017d9b1b4142">&#9670;&nbsp;</a></span>setCalculateNormalVectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setCalculateNormalVectors </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cnv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether normal vectors should be calculated at each level set point. Defaults to true. If normal vectors are not required for velocity calculation, this can be set to false, in order to increase computational efficiency. </p>

</div>
</div>
<a id="af644ebf0efd6dbef33865a9c5c61988c" name="af644ebf0efd6dbef33865a9c5c61988c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af644ebf0efd6dbef33865a9c5c61988c">&#9670;&nbsp;</a></span>setDissipationAlpha() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setDissipationAlpha </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the alpha dissipation coefficient. For lsLaxFriedrichs, this is used as the alpha value. For all other LaxFriedrichs schemes it is used as a scaling factor for the calculated alpha values. </p>

</div>
</div>
<a id="af644ebf0efd6dbef33865a9c5c61988c" name="af644ebf0efd6dbef33865a9c5c61988c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af644ebf0efd6dbef33865a9c5c61988c">&#9670;&nbsp;</a></span>setDissipationAlpha() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setDissipationAlpha </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the alpha dissipation coefficient. For lsLaxFriedrichs, this is used as the alpha value. For all other LaxFriedrichs schemes it is used as a scaling factor for the calculated alpha values. </p>

</div>
</div>
<a id="a520e28feacd2655a4eff2a33e1d7f92d" name="a520e28feacd2655a4eff2a33e1d7f92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520e28feacd2655a4eff2a33e1d7f92d">&#9670;&nbsp;</a></span>setIgnoreVoids() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setIgnoreVoids </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>iV</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether level set values, which are not part of the "top" geometrically connected part of values, should be advected. The "top" part is identified by the most positive part in the lowest dimension with INFINITE boundary conditions. Defaults to false. If set to true, only the "top" values will be advected. All others values are not changed. </p>

</div>
</div>
<a id="a520e28feacd2655a4eff2a33e1d7f92d" name="a520e28feacd2655a4eff2a33e1d7f92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520e28feacd2655a4eff2a33e1d7f92d">&#9670;&nbsp;</a></span>setIgnoreVoids() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setIgnoreVoids </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>iV</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether level set values, which are not part of the "top" geometrically connected part of values, should be advected. The "top" part is identified by the most positive part in the lowest dimension with INFINITE boundary conditions. Defaults to false. If set to true, only the "top" values will be advected. All others values are not changed. </p>

</div>
</div>
<a id="a5f46e20b204edca8a987514909e34907" name="a5f46e20b204edca8a987514909e34907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f46e20b204edca8a987514909e34907">&#9670;&nbsp;</a></span>setIntegrationScheme() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setIntegrationScheme </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="include_2lsAdvect_8hpp.html#afe9778bbf7b5f9aeb52d14c4f133cc9b">lsIntegrationSchemeEnum</a>&#160;</td>
          <td class="paramname"><em>scheme</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set which integration scheme should be used out of the ones specified in lsIntegrationSchemeEnum. </p>

</div>
</div>
<a id="a5f46e20b204edca8a987514909e34907" name="a5f46e20b204edca8a987514909e34907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f46e20b204edca8a987514909e34907">&#9670;&nbsp;</a></span>setIntegrationScheme() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setIntegrationScheme </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="include_2lsAdvect_8hpp.html#afe9778bbf7b5f9aeb52d14c4f133cc9b">lsIntegrationSchemeEnum</a>&#160;</td>
          <td class="paramname"><em>scheme</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set which integration scheme should be used out of the ones specified in lsIntegrationSchemeEnum. </p>

</div>
</div>
<a id="a1f78eb026aa00ec77cf420fe3674dd03" name="a1f78eb026aa00ec77cf420fe3674dd03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f78eb026aa00ec77cf420fe3674dd03">&#9670;&nbsp;</a></span>setSaveAdvectionVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setSaveAdvectionVelocities </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sAV</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether the velocities applied to each point should be saved in the level set for debug purposes. </p>

</div>
</div>
<a id="a1f78eb026aa00ec77cf420fe3674dd03" name="a1f78eb026aa00ec77cf420fe3674dd03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f78eb026aa00ec77cf420fe3674dd03">&#9670;&nbsp;</a></span>setSaveAdvectionVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setSaveAdvectionVelocities </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sAV</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether the velocities applied to each point should be saved in the level set for debug purposes. </p>

</div>
</div>
<a id="accf51dda5ac4830d9b54f1d4ef15ba57" name="accf51dda5ac4830d9b54f1d4ef15ba57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf51dda5ac4830d9b54f1d4ef15ba57">&#9670;&nbsp;</a></span>setSingleStep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setSingleStep </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>singleStep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set to true, only a single advection step will be performed, even if the advection time set with <a class="el" href="classlsAdvect.html#ad0504339e8d545dfec417acd5c6b0eb7" title="Set the time until when the level set should be advected. If this takes more than one advection step,...">setAdvectionTime(double)</a> would require several steps to pass. Defaults to false. </p>

</div>
</div>
<a id="accf51dda5ac4830d9b54f1d4ef15ba57" name="accf51dda5ac4830d9b54f1d4ef15ba57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf51dda5ac4830d9b54f1d4ef15ba57">&#9670;&nbsp;</a></span>setSingleStep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setSingleStep </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>singleStep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set to true, only a single advection step will be performed, even if the advection time set with <a class="el" href="classlsAdvect.html#ad0504339e8d545dfec417acd5c6b0eb7" title="Set the time until when the level set should be advected. If this takes more than one advection step,...">setAdvectionTime(double)</a> would require several steps to pass. Defaults to false. </p>

</div>
</div>
<a id="ac1ec99a52859c693e3c8741f50329a7e" name="ac1ec99a52859c693e3c8741f50329a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ec99a52859c693e3c8741f50329a7e">&#9670;&nbsp;</a></span>setTimeStepRatio() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setTimeStepRatio </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>cfl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the CFL condition to use during advection. The CFL condition sets the maximum distance a surface can be moved during one advection step. It MUST be below 0.5 to guarantee numerical stability. Defaults to 0.4999. </p>

</div>
</div>
<a id="ac1ec99a52859c693e3c8741f50329a7e" name="ac1ec99a52859c693e3c8741f50329a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ec99a52859c693e3c8741f50329a7e">&#9670;&nbsp;</a></span>setTimeStepRatio() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setTimeStepRatio </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>cfl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the CFL condition to use during advection. The CFL condition sets the maximum distance a surface can be moved during one advection step. It MUST be below 0.5 to guarantee numerical stability. Defaults to 0.4999. </p>

</div>
</div>
<a id="a58b680304b836eaf906539a86633b1ab" name="a58b680304b836eaf906539a86633b1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b680304b836eaf906539a86633b1ab">&#9670;&nbsp;</a></span>setUpdatePointData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setUpdatePointData </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether the point data in the old LS should be translated to the advected LS. Defaults to true. </p>

</div>
</div>
<a id="a58b680304b836eaf906539a86633b1ab" name="a58b680304b836eaf906539a86633b1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b680304b836eaf906539a86633b1ab">&#9670;&nbsp;</a></span>setUpdatePointData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setUpdatePointData </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether the point data in the old LS should be translated to the advected LS. Defaults to true. </p>

</div>
</div>
<a id="a33f8966aac303d434345cca2b6139815" name="a33f8966aac303d434345cca2b6139815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f8966aac303d434345cca2b6139815">&#9670;&nbsp;</a></span>setVelocityField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<div class="memtemplate">
template&lt;class VelocityField , <a class="el" href="namespacelsConcepts.html#a90d0ed377343607596475f042f71ae47">lsConcepts::IsBaseOf</a>&lt; <a class="el" href="classlsVelocityField.html">lsVelocityField</a>&lt; T &gt;, VelocityField &gt;  = lsConcepts::assignable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setVelocityField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt;&#160;</td>
          <td class="paramname"><em>passedVelocities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the velocity field used for advection. This should be a concrete implementation of <a class="el" href="classlsVelocityField.html" title="Abstract class defining the interface for the velocity field used during advection using lsAdvect.">lsVelocityField</a>. </p>

</div>
</div>
<a id="a33f8966aac303d434345cca2b6139815" name="a33f8966aac303d434345cca2b6139815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f8966aac303d434345cca2b6139815">&#9670;&nbsp;</a></span>setVelocityField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<div class="memtemplate">
template&lt;class VelocityField , <a class="el" href="namespacelsConcepts.html#a90d0ed377343607596475f042f71ae47">lsConcepts::IsBaseOf</a>&lt; <a class="el" href="classlsVelocityField.html">lsVelocityField</a>&lt; T &gt;, VelocityField &gt;  = lsConcepts::assignable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::setVelocityField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlsSmartPointer.html">lsSmartPointer</a>&lt; VelocityField &gt;&#160;</td>
          <td class="paramname"><em>passedVelocities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the velocity field used for advection. This should be a concrete implementation of <a class="el" href="classlsVelocityField.html" title="Abstract class defining the interface for the velocity field used during advection using lsAdvect.">lsVelocityField</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afae1b077486e6aa98c423cbe0b84c2e0" name="afae1b077486e6aa98c423cbe0b84c2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae1b077486e6aa98c423cbe0b84c2e0">&#9670;&nbsp;</a></span>velocityLabel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr char <a class="el" href="classlsAdvect.html">lsAdvect</a>&lt; T, D &gt;::velocityLabel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="include_2lsAdvect_8hpp.html">lsAdvect.hpp</a></li>
<li>install/ViennaLS/include/<a class="el" href="install_2ViennaLS_2include_2lsAdvect_8hpp.html">lsAdvect.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classlsAdvect.html">lsAdvect</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>

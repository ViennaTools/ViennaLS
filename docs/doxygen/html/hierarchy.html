<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ViennaLS: Class Hierarchy</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ViennaLS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('hierarchy.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Class Hierarchy</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">This inheritance list is sorted roughly, but not completely, alphabetically:</div><div class="directory">
<div class="levels">[detail level <span onclick="javascript:toggleLevel(1);">1</span><span onclick="javascript:toggleLevel(2);">2</span>]</div><table class="directory">
<tr id="row_0_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsFromSurfaceMesh_1_1box_1_1iterator.html" target="_self">lsFromSurfaceMesh&lt; T, D &gt;::box::iterator</a></td><td class="desc">Iterator over all grid points, contained by a box </td></tr>
<tr id="row_1_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsAdvect.html" target="_self">lsAdvect&lt; T, D &gt;</a></td><td class="desc">This class is used to advance level sets over time. Level sets are passed to the constructor in an std::vector, with the last element being the level set to advect, or "top level set", while the others are then adjusted afterwards. In order to ensure that advection works correctly, the "top level set" has to include all lower level sets: LS_top = LS_top U LS_i for i = {0 ... n}, where n is the number of level sets. The velocities used to advect the level set are given in a concrete implementation of the <a class="el" href="classlsVelocityField.html" title="Abstract class defining the interface for the velocity field used during advection using lsAdvect.">lsVelocityField</a> (check Advection examples for guidance) </td></tr>
<tr id="row_2_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsBooleanOperation.html" target="_self">lsBooleanOperation&lt; T, D &gt;</a></td><td class="desc">This class is used to perform boolean operations on two level sets and write the resulting level set into the first passed level set. When the boolean operation is set to CUSTOM, a comparator must be set using setBooleanOperationComparator. This comparator returns one value generated from the level set value supplied by each level set. E.g.: for a union, the comparator will always return the smaller of the two values </td></tr>
<tr id="row_3_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsBox.html" target="_self">lsBox&lt; T, D &gt;</a></td><td class="desc">Class describing a square box from one coordinate to another </td></tr>
<tr id="row_4_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsCalculateNormalVectors.html" target="_self">lsCalculateNormalVectors&lt; T, D &gt;</a></td><td class="desc">This algorithm is used to compute the normal vectors for all points with level set values &lt;= 0.5. The result is saved in the <a class="el" href="classlsPointData.html" title="This class holds data associated with points in space.">lsPointData</a> of the <a class="el" href="classlsDomain.html" title="Class containing all information about the level set, including the dimensions of the domain,...">lsDomain</a> and can be retrieved with <a class="el" href="classlsDomain.html#a927530a0e159079db3f61fe8bce8f25a" title="get reference to point data saved in the level set">lsDomain.getPointData()</a>.getVectorData("Normals"). Since neighbors in each cartesian direction are necessary for the calculation, the levelset width must be &gt;=3 </td></tr>
<tr id="row_5_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsCheck.html" target="_self">lsCheck&lt; T, D &gt;</a></td><td class="desc">This class is used to find errors in the underlying level set structure, like invalid neighbours of different signs </td></tr>
<tr id="row_6_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsConvexHull.html" target="_self">lsConvexHull&lt; T, D &gt;</a></td><td class="desc">This algorithm creates a convex hull mesh from a point cloud. This is done using the gift wrapping approach. The points in the point cloud MUST be unique, otherwise this will fail </td></tr>
<tr id="row_7_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsCylinder.html" target="_self">lsCylinder&lt; T, D &gt;</a></td><td class="desc">Class describing a square box from one coordinate to another </td></tr>
<tr id="row_8_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsDomain.html" target="_self">lsDomain&lt; T, D &gt;</a></td><td class="desc">Class containing all information about the level set, including the dimensions of the domain, boundary conditions and all data </td></tr>
<tr id="row_9_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsInternal_1_1lsEnquistOsher.html" target="_self">lsInternal::lsEnquistOsher&lt; T, D, order &gt;</a></td><td class="desc">Engquist osher integration scheme based on the upwind integration scheme. Offers high performance but lower accuracy for complex velocity fields </td></tr>
<tr id="row_10_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsExpand.html" target="_self">lsExpand&lt; T, D &gt;</a></td><td class="desc">Expands the leveleSet to the specified number of layers. The largest value in the levelset is thus width*0.5 Returns the number of added points </td></tr>
<tr id="row_11_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsInternal_1_1lsFiniteDifferences.html" target="_self">lsInternal::lsFiniteDifferences&lt; T, scheme &gt;</a></td><td class="desc"></td></tr>
<tr id="row_12_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsFromMesh.html" target="_self">lsFromMesh&lt; T, D &gt;</a></td><td class="desc">Import the regular grid, on which the level set values are defined, from an explicit lsMesh&lt;&gt;. The Vertices must be defined, as well as a scalar data field "LSValues". If used for custom read-in, make sure all vertices are lexicographically sorted </td></tr>
<tr id="row_13_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsFromSurfaceMesh.html" target="_self">lsFromSurfaceMesh&lt; T, D &gt;</a></td><td class="desc">Construct a level set from an explicit mesh </td></tr>
<tr id="row_14_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsFromVolumeMesh.html" target="_self">lsFromVolumeMesh&lt; T, D &gt;</a></td><td class="desc">This class creates a level set from a tetrahedral mesh. If the mesh contains a scalar data array called "Material", one level set for each material will be created and stored in the supplied std::vector&lt;lsDomain&lt;T,D&gt;&gt; object </td></tr>
<tr id="row_15_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsGeometricAdvect.html" target="_self">lsGeometricAdvect&lt; T, D &gt;</a></td><td class="desc">This class advects the level set according to a given distribution. This distribution is overlayed at every grid point of the old surface. All cells within this distribution are then filled, with cells at the edge marked with the correct level set values. Therefore, the surface can be shifted long distances in one step. This algorithm is therefore preferable to normal advection if there is growth/reduction by a purely geometric directional distribution </td></tr>
<tr id="row_16_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_16_" class="arrow" onclick="toggleFolder('16_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsGeometricAdvectDistribution.html" target="_self">lsGeometricAdvectDistribution&lt; T, D &gt;</a></td><td class="desc">Base class for distributions used by <a class="el" href="classlsGeometricAdvect.html" title="This class advects the level set according to a given distribution. This distribution is overlayed at...">lsGeometricAdvect</a>. All functions are pure virtual and must be implemented by any advection distribution </td></tr>
<tr id="row_16_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsBoxDistribution.html" target="_self">lsBoxDistribution&lt; T, D &gt;</a></td><td class="desc">Concrete implementation of <a class="el" href="classlsGeometricAdvectDistribution.html" title="Base class for distributions used by lsGeometricAdvect. All functions are pure virtual and must be im...">lsGeometricAdvectDistribution</a> for a rectangular box distribution </td></tr>
<tr id="row_16_1_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsSphereDistribution.html" target="_self">lsSphereDistribution&lt; T, D &gt;</a></td><td class="desc">Concrete implementation of <a class="el" href="classlsGeometricAdvectDistribution.html" title="Base class for distributions used by lsGeometricAdvect. All functions are pure virtual and must be im...">lsGeometricAdvectDistribution</a> for a spherical advection distribution </td></tr>
<tr id="row_17_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsInternal_1_1lsGraph.html" target="_self">lsInternal::lsGraph</a></td><td class="desc"></td></tr>
<tr id="row_18_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsInternal_1_1lsLaxFriedrichs.html" target="_self">lsInternal::lsLaxFriedrichs&lt; T, D, order &gt;</a></td><td class="desc">Lax Friedrichs integration scheme with constant alpha value for dissipation. This alpha value should be fitted based on the results of the advection and passed to the advection Kernel </td></tr>
<tr id="row_19_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsInternal_1_1lsLocalLaxFriedrichs.html" target="_self">lsInternal::lsLocalLaxFriedrichs&lt; T, D, order &gt;</a></td><td class="desc">Lax Friedrichs integration scheme, which uses a first neighbour stencil to calculate the alpha values for all neighbours. The largest alpha value is then chosen for dissipation. Slower than <a class="el" href="classlsInternal_1_1lsLocalLocalLaxFriedrichs.html" title="Lax Friedrichs integration scheme, which considers only the current point for alpha calculation....">lsLocalLocalLaxFriedrichs</a> or lsEngquistOsher but more reliable for complex velocity fields </td></tr>
<tr id="row_20_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsInternal_1_1lsLocalLaxFriedrichsAnalytical.html" target="_self">lsInternal::lsLocalLaxFriedrichsAnalytical&lt; T, D, order &gt;</a></td><td class="desc">Lax Friedrichs integration scheme, which uses alpha values provided by the user in getDissipationAlphas in <a class="el" href="classlsVelocityField.html" title="Abstract class defining the interface for the velocity field used during advection using lsAdvect.">lsVelocityField</a>. If it is possible to derive analytical solutions for the velocityField and the alpha values, this integration scheme should be used and never otherwise </td></tr>
<tr id="row_21_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsInternal_1_1lsLocalLocalLaxFriedrichs.html" target="_self">lsInternal::lsLocalLocalLaxFriedrichs&lt; T, D, order &gt;</a></td><td class="desc">Lax Friedrichs integration scheme, which considers only the current point for alpha calculation. Faster than <a class="el" href="classlsInternal_1_1lsLocalLaxFriedrichs.html" title="Lax Friedrichs integration scheme, which uses a first neighbour stencil to calculate the alpha values...">lsLocalLaxFriedrichs</a> but not as accurate </td></tr>
<tr id="row_22_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsMakeGeometry.html" target="_self">lsMakeGeometry&lt; T, D &gt;</a></td><td class="desc">Create level sets describing basic geometric forms </td></tr>
<tr id="row_23_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsInternal_1_1lsMarchingCubes.html" target="_self">lsInternal::lsMarchingCubes</a></td><td class="desc">Helper class for <a class="el" href="classlsToSurfaceMesh.html" title="Extract an explicit lsMesh&lt;&gt; instance from an lsDomain. The interface is then described by explciit s...">lsToSurfaceMesh</a>. Should not be used directly </td></tr>
<tr id="row_24_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsMarkVoidPoints.html" target="_self">lsMarkVoidPoints&lt; T, D &gt;</a></td><td class="desc">This class is used to mark points of the level set which are enclosed in a void </td></tr>
<tr id="row_25_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsMessage.html" target="_self">lsMessage</a></td><td class="desc">Singleton class for thread-safe logging </td></tr>
<tr id="row_26_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsPlane.html" target="_self">lsPlane&lt; T, D &gt;</a></td><td class="desc">Class describing a plane via a point in it and the plane normal </td></tr>
<tr id="row_27_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsPointCloud.html" target="_self">lsPointCloud&lt; T, D &gt;</a></td><td class="desc">Class describing a point cloud, which can be used to create geometries from its convex hull mesh </td></tr>
<tr id="row_28_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsPointData.html" target="_self">lsPointData&lt; T, &gt;</a></td><td class="desc">This class holds data associated with points in space </td></tr>
<tr id="row_29_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_29_" class="arrow" onclick="toggleFolder('29_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsPointData.html" target="_self">lsPointData&lt; double &gt;</a></td><td class="desc"></td></tr>
<tr id="row_29_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsMesh.html" target="_self">lsMesh&lt; T &gt;</a></td><td class="desc">This class holds an explicit mesh, which is always given in 3 dimensions. If it describes a 2D mesh, the third dimension is set to 0. Vertices, Lines, Triangles, Tetras &amp; Hexas are supported as geometric elements </td></tr>
<tr id="row_30_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsPointData.html" target="_self">lsPointData&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_31_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsPrune.html" target="_self">lsPrune&lt; T, D &gt;</a></td><td class="desc">Removes all level set points, which do not have at least one oppositely signed neighbour (Meaning they do not lie directly at the interface). Afterwards the level set will occupy the least memory possible </td></tr>
<tr id="row_32_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsReader.html" target="_self">lsReader&lt; T, D &gt;</a></td><td class="desc"></td></tr>
<tr id="row_33_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsReduce.html" target="_self">lsReduce&lt; T, D &gt;</a></td><td class="desc">Reduce the level set size to the specified width. This means all level set points with value &lt;= 0.5*width are removed, reducing the memory footprint of the <a class="el" href="classlsDomain.html" title="Class containing all information about the level set, including the dimensions of the domain,...">lsDomain</a> </td></tr>
<tr id="row_34_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsSphere.html" target="_self">lsSphere&lt; T, D &gt;</a></td><td class="desc">Class describing a sphere via origin and radius </td></tr>
<tr id="row_35_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsInternal_1_1lsStencilLocalLaxFriedrichsScalar.html" target="_self">lsInternal::lsStencilLocalLaxFriedrichsScalar&lt; T, D, order &gt;</a></td><td class="desc">Stencil Local Lax Friedrichs Integration Scheme. It uses a stencil of order around active points, in order to evaluate dissipation values for each point, taking into account the mathematical nature of the speed function. see Toifl et al., 2019. ISBN: 978-1-7281-0938-1; DOI: 10.1109/SISPAD.2019.8870443 </td></tr>
<tr id="row_36_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsToDiskMesh.html" target="_self">lsToDiskMesh&lt; T, D, N &gt;</a></td><td class="desc">This class creates a mesh from the level set with all grid points with a level set value &lt;= 0.5. These grid points are shifted in space towards the direction of their normal vector by grid delta * LS value. Grid delta and the origin grid point are saved for each point. This allows for a simple setup of disks for ray tracing </td></tr>
<tr id="row_37_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsToMesh.html" target="_self">lsToMesh&lt; T, D &gt;</a></td><td class="desc">Extract the regular grid, on which the level set values are defined, to an explicit lsMesh&lt;&gt;. The Vertices will contain the level set value stored at its location. (This is very useful for debugging) </td></tr>
<tr id="row_38_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsToSurfaceMesh.html" target="_self">lsToSurfaceMesh&lt; T, D &gt;</a></td><td class="desc">Extract an explicit lsMesh&lt;&gt; instance from an <a class="el" href="classlsDomain.html" title="Class containing all information about the level set, including the dimensions of the domain,...">lsDomain</a>. The interface is then described by explciit surface elements: Lines in 2D, Triangles in 3D </td></tr>
<tr id="row_39_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsToVoxelMesh.html" target="_self">lsToVoxelMesh&lt; T, D &gt;</a></td><td class="desc">Creates a mesh, which consists only of quads/hexas for completely filled grid cells in the level set. Interfaces will not be smooth but stepped. (This can be used to create meshes for finite difference algorithms) </td></tr>
<tr id="row_40_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsTransformMesh.html" target="_self">lsTransformMesh&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_41_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_41_" class="arrow" onclick="toggleFolder('41_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><b>lsVelocityField</b></td><td class="desc"></td></tr>
<tr id="row_41_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classAirGapDeposition_1_1velocityField.html" target="_self">AirGapDeposition.velocityField</a></td><td class="desc"></td></tr>
<tr id="row_41_1_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classDeposition_1_1velocityField.html" target="_self">Deposition.velocityField</a></td><td class="desc"></td></tr>
<tr id="row_42_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsVelocityField.html" target="_self">lsVelocityField&lt; T &gt;</a></td><td class="desc">Abstract class defining the interface for the velocity field used during advection using <a class="el" href="classlsAdvect.html" title="This class is used to advance level sets over time. Level sets are passed to the constructor in an st...">lsAdvect</a> </td></tr>
<tr id="row_43_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsVelocityField.html" target="_self">lsVelocityField&lt; double &gt;</a></td><td class="desc"></td></tr>
<tr id="row_44_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsVelocityField.html" target="_self">lsVelocityField&lt; NumericType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_45_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsVTKReader.html" target="_self">lsVTKReader&lt; T &gt;</a></td><td class="desc">Class handling the import of VTK file types </td></tr>
<tr id="row_46_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsVTKWriter.html" target="_self">lsVTKWriter&lt; T &gt;</a></td><td class="desc">Class handling the output of an lsMesh&lt;&gt; to VTK file types </td></tr>
<tr id="row_47_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsWriter.html" target="_self">lsWriter&lt; T, D &gt;</a></td><td class="desc"></td></tr>
<tr id="row_48_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsWriteVisualizationMesh.html" target="_self">lsWriteVisualizationMesh&lt; T, D &gt;</a></td><td class="desc">This algorithm is used to extract tetrahedral volume meshes and triangle hull meshes with material numbers sorted by order of input of level sets. It should ONLY BE USED FOR VISUALIZATION because the algorithm does not guarantee manifold meshes, which should not be a problem for visualization. In order to obtain a hull triangle mesh from the outline of each material, use setExtractHull(true) </td></tr>
<tr id="row_49_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_49_" class="arrow" onclick="toggleFolder('49_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><b>shared_ptr</b></td><td class="desc"></td></tr>
<tr id="row_49_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsSmartPointer.html" target="_self">lsSmartPointer&lt; T &gt;</a></td><td class="desc">Std::shared_ptr wrapper for use with ViennaLS. lsSmartPointers should be created using the function ::New(...). All other interface functions are identical to std::shared_ptr </td></tr>
<tr id="row_49_1_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsSmartPointer.html" target="_self">lsSmartPointer&lt; const lsGeometricAdvectDistribution&lt; hrleCoordType, D &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_2_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsSmartPointer.html" target="_self">lsSmartPointer&lt; lsBox&lt; T, D &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_3_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsSmartPointer.html" target="_self">lsSmartPointer&lt; lsCylinder&lt; T, D &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_4_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsSmartPointer.html" target="_self">lsSmartPointer&lt; lsDomain&lt; T, D &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_5_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsSmartPointer.html" target="_self">lsSmartPointer&lt; lsMesh&lt; double &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_6_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsSmartPointer.html" target="_self">lsSmartPointer&lt; lsMesh&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_7_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsSmartPointer.html" target="_self">lsSmartPointer&lt; lsPlane&lt; T, D &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_8_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsSmartPointer.html" target="_self">lsSmartPointer&lt; lsPointCloud&lt; T, D &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_9_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsSmartPointer.html" target="_self">lsSmartPointer&lt; lsSphere&lt; T, D &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_10_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classlsSmartPointer.html" target="_self">lsSmartPointer&lt; lsVelocityField&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
</table>
</div><!-- directory -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
